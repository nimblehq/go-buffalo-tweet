package actions

import (
	"github.com/bufftwitt/models"
	"github.com/gobuffalo/buffalo"
	"github.com/markbates/pop"
	"github.com/pkg/errors"
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (Tweet)
// DB Table: Plural (tweets)
// Resource: Plural (Tweets)
// Path: Plural (/tweets)
// View Template Folder: Plural (/templates/tweets/)

// TweetsResource is the resource for the Tweet model
type AllTweetsResource struct {
	buffalo.Resource
}

// List gets all Tweets. This function is mapped to the path
// GET /tweets
func (v AllTweetsResource) List(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	tweets := &models.Tweets{}

	// Paginate results. Params "page" and "per_page" control pagination.
	// Default values are "page=1" and "per_page=20".
	q := tx.PaginateFromParams(c.Params())

	// Retrieve all Tweets from the DB
	if err := q.All(tweets); err != nil {
		return errors.WithStack(err)
	}

	// Make Tweets available inside the html template
	c.Set("tweets", tweets)

	// Add the paginator to the context so it can be used in the template.
	c.Set("pagination", q.Paginator)

	return c.Render(200, r.HTML("tweets/list_all.html"))
}
